
1. Introduction to Optimizations (Simulation)
    ->Optimization in simulation aims to improve logic efficiency and verify performance without physically modifying hardware.
    ->Focuses on critical paths, redundant logic, and resource usage within the simulated design.
    ->Tools analyze the RTL (Register Transfer Level) to highlight timing, area, and logic improvements.

2. Combinational Logic Optimizations
    ->Targets logic simplification and delay reduction in simulated circuits.
    ->Techniques demonstrated in simulation:
        =>Boolean simplification to reduce unnecessary gates.
        =>Common sub-expression elimination to reuse logic signals.
        =>Buffer insertion or restructuring to balance delays.
        =>Simulation shows the effect on propagation delays, critical paths, and output waveforms.

3. Sequential Logic Optimizations
    ->Focuses on improving flip-flops, registers, and timing paths in the simulation model.
    ->Techniques in simulation:
        =>Register retiming: Moving flip-flops in simulation to see timing improvements.
        =>Merging or removing redundant registers to optimize the design model.
        =>Clock gating in simulation to observe power reduction and reduced switching activity.
    ->Simulation verifies functional correctness after these optimizations.

4. Sequential Optimizations for Unused Outputs
    ->Simulation detects unused signals or outputs and removes them virtually.
    ->Helps to reduce logic complexity and simulation run-time.
    ->Ensures the RTL model remains efficient and clean for testing or further synthesis.

5. General Coding Guidelines for Simulation
    ->Write modular and clean RTL code to allow optimizations in simulation.
    ->Avoid redundant or unnecessary logic to make waveform verification easier.
    ->Use clock enables and synchronous resets in simulated flops.
    ->Structure sequential logic so retiming and other virtual optimizations can be applied without breaking the model.
    ->Keep combinational logic depth manageable for accurate and fast simulation results.

6. DFF (Flip-Flops) Simulation Focus: Verify edge-triggered behavior, setup timing, enable signals, and reset operations;
code should use always_ff blocks for clarity and support virtual optimizations.
